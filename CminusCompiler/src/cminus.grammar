Package cminus ; 
     
Helpers
 	all = [0 .. 0xFFFF];  
    lowercase = ['a' .. 'z'];
    uppercase = ['A' .. 'Z'];
    digit = ['0' .. '9'];

    tab = 9;
    cr = 13; // carriage return
    lf = 10; //new line
    eol = cr lf | cr | lf; // End Of Line - This takes care of different platforms

    not_cr_lf = [all - [cr + lf]];
    not_star = [all - '*'];
    not_star_slash = [not_star - '/'];

    blank = (' ' | tab | eol)+;

    short_comment = '//' not_cr_lf* eol;
    //long_comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';

    letter = lowercase | uppercase;
    
States
  normal,
  comment,
  short_comment; 
  
Tokens 
	{normal} else = 'else';
	{normal} if = 'if';
	{normal} int = 'int';
	{normal} string = 'string';
	{normal} return = 'return';
	{normal} void = 'void';
	{normal} while = 'while';
 	{normal} plus = '+';
 	{normal} minus = '-';
 	{normal} mult = '*';
 	{normal} div = '/';
 	{normal} less = '<';
 	{normal} lessorequal = '<=';
 	{normal} greater = '>';
 	{normal} greaterorequal = '>=';
 	{normal} equal = '==';
 	{normal} different = '!=';
 	{normal} assignment = '=';
 	{normal} semi = ';';
 	{normal} colon = ',';
 	{normal} l_par = '(';
 	{normal} r_par = ')';
 	{normal} l_bra = '[';
 	{normal} r_bra = ']';
 	{normal} l_cur = '{';
 	{normal} r_cur = '}';
 	{normal} d_quotes = '"';
    {normal} num = digit + digit*;
    {normal} id = letter + letter*;
    {normal} blank = blank;
    
    {normal->comment, comment}
          comment = '/*'|'/*';
          
    short_comment = short_comment;
    
    comment_end = '*/';
	{comment} comment_body = [all -['*' + '/']]*;
	{comment} star = '*';
	{comment} slash = '/';
    
Ignored Tokens
	blank,
	short_comment,
	comment, comment_end, comment_body;
  
Productions //TODO
    program = 
    		{lista_declaracoes} lista_declaracoes;
    		
    lista_declaracoes = 
    		{lista_decl} lista_declaracoes declaracao |
    		{unica_decl} declaracao;
    
    declaracao = 
    		{decl_var} decl_var | 
    		{decl_fun} decl_fun;
    					
    decl_var = 
    		{tipo} tipo id semi;
    
    tipo = 
    		{string_var} string |
    		{int_var} int;
   
   	decl_fun =
   			{normal_fun} tipo id l_par parametros r_par instrucoes_compostas |
   			{void_fun} void id l_par parametros r_par instrucoes_compostas;
   	
   	parametros = 
   			{lista_parametro} lista_parametro|
   			{void_parametro}  void;
   	
   	lista_parametro = 
   			{multiparametro} lista_parametro colon parametro|
   			{parametro} parametro;
   	
   	parametro = 
   			{decl_param} tipo id;
   	
   	instrucoes_compostas =
   			{lista_instrucoes} l_cur decl_local lista_instrucoes r_cur;
   			
   	decl_local =
   			{declara_var} decl_local decl_var;
   			
   	lista_instrucoes =
   			{instrucoes} lista_instrucoes instrucao |
   			{instrucao} instrucao;
   			
   	instrucao =
		   	{nao_pendente} nao_pendente |
			{pendente} pendente;  			
    	

	nao_pendente =
		{ifelse} if l_par expr r_par nao_pendente else [other]:nao_pendente |
		{inst_expr} inst_expr |
		{instrucoes_compostas} instrucoes_compostas |
		{inst_return} inst_return;
		
	pendente =
		{if_pendente} if l_par expr r_par instrucao |
		{ifelse_pendente} if l_par expr r_par nao_pendente else pendente |
		{inst_while} inst_while ;
		
	inst_expr =
		{expr} expr semi ;
			
	inst_while =  
			{instrucao_while} while l_par expr r_par instrucao;
			
	inst_return = 
			{instrucao_return} return expr semi;
			
	expr = 
			{atribuicao} id assignment expr |
			{expr_simples} expr_simples;
	
    expr_simples =
    		{expr_comparacao} [first]:expr_soma logic [second]:expr_soma |
    		{expr_soma} expr_soma;
    		
   	logic =
   			{menor} less |
 			{menorigual} lessorequal |
 			{maior} greater |
 			{maiorigual} greaterorequal |
 			{igual} equal |
 			{diferente} different;	
 			
 	expr_soma =
 			{soma} expr_soma soma_op termo |
 			{termo} termo;
 			
 	soma_op =
 			{plus_op} plus |
 			{minus_op} minus;
 			
 	termo =
 			{termo_expr} termo mult_op fator |
 			{fator} fator;
 			
 	mult_op =
 			{mult_op} mult |
 			{div_op} div;
 			
 	fator =
 			{fator_expr} l_par expr r_par |
 			{fator_var} id |
 			{chamada_fun} chamada_fun |
 			{numero} num;
 			
 	chamada_fun = 
 			{chama_fun} id l_par args r_par;
 			
 	args = 
 			{com_args} lista_args |
 			{sem_args} void;
 	
 	lista_args =
 			{multi_args} lista_args colon expr |
 			{um_args} expr;